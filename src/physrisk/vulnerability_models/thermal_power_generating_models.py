from collections import defaultdict

import numpy as np

from physrisk.api.v1.common import VulnerabilityCurves
from physrisk.data.hazard_data_provider import HazardDataBufferZone
from physrisk.kernel.assets import Asset, Cooling, ThermalPowerGeneratingAsset, Turbine, TurbineKind
from physrisk.kernel.vulnerability_matrix_provider import VulnMatrixProvider
from physrisk.kernel.vulnerability_model import VulnerabilityModel

from ..kernel.hazards import CoastalInundation, RiverineInundation
from ..kernel.vulnerability_model import applies_to_events, cdf_max_of, checked_beta_distrib, get_vulnerability_curves_from_resource


class ThermalPowerGeneratingInundationModel(VulnerabilityModel):
    _default_impact_bin_edges = np.array([0, 0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0])
    _default_resource = "WRI thermal power plant physical climate vulnerability factors"
    _default_buffer_zone = HazardDataBufferZone(delta_deg=0.01, n_grid=10)

    def __init__(
        self,
        *,
        event_type: type,
        indicator_id: str,
        resource: str = _default_resource,
        impact_bin_edges=_default_impact_bin_edges,
        buffer_zone=_default_buffer_zone
    ):
        """
        Inundation vulnerability model for thermal power generating assets. Applies to both riverine and coastal inundation.

        Args:
            event_type: Event type.
            model: optional identifier for hazard event model, passed to HazardModel.
            resource: embedded resource identifier used to infer vulnerability matrix.
            impact_bin_edges: specifies the impact (fractional damage/disruption bins).
        """

        curve_set: VulnerabilityCurves = get_vulnerability_curves_from_resource(resource)

        # for this model, key for looking up curves is asset_type, e.g. 'Steam/Recirculating'
        self.vulnerability_curves = dict((c.asset_type, c) for c in curve_set.items if c.event_type == event_type.__base__.__name__.lower())
        self.vuln_curves_by_type = defaultdict(list)
        for key in self.vulnerability_curves:
            self.vuln_curves_by_type[TurbineKind[key.split('/')[0]]].append(self.vulnerability_curves[key])

        # global circulation parameter 'model' is a hint; can be overriden by hazard model
        super().__init__(indicator_id=indicator_id, hazard_type=event_type, impact_bin_edges=impact_bin_edges, buffer_zone=buffer_zone)


    def get_impact_curve(self, intensity_bin_centres: np.ndarray, asset: Asset):
        # we interpolate the mean and standard deviation and use this to construct distributions
        assert isinstance(asset, ThermalPowerGeneratingAsset)

        turbine_type = Turbine.kind(type(asset.turbine))
        curves = self.vuln_curves_by_type[turbine_type]
        if turbine_type == TurbineKind.steam and asset.turbine.cooling is not None:
            cooling_type = Cooling.kind(type(asset.turbine.cooling))
            key = [turbine_type, cooling_type].join('/')
            curves = [self.vulnerability_curves[key]]

        impact_means = np.transpose([np.interp(intensity_bin_centres, curve.intensity, curve.impact_mean) for curve in curves])
        impact_stddevs = np.transpose([np.interp(intensity_bin_centres, curve.intensity, curve.impact_std) if len(curve.impact_std) == len(curve.intensity) else [0.0 for _ in curve.intensity] for curve in curves])

        return VulnMatrixProvider(
            intensity_bin_centres,
            impact_cdfs=\
            [
                checked_beta_distrib(mm[0], ss[0])
                if len(mm) == 1 else cdf_max_of([checked_beta_distrib(m, s) for m, s in zip(mm, ss)])
                for mm, ss in zip(impact_means, impact_stddevs)
            ]
        )


@applies_to_events([CoastalInundation])
class ThermalPowerGeneratingCoastalInundationModel(ThermalPowerGeneratingInundationModel):
    def __init__(
        self,
        *,
        indicator_id: str = "flood_depth",
        resource: str = ThermalPowerGeneratingInundationModel._default_resource,
        impact_bin_edges = ThermalPowerGeneratingInundationModel._default_impact_bin_edges
    ):
        # by default include subsidence and 95% sea-level rise
        super().__init__(
            event_type=CoastalInundation,
            indicator_id=indicator_id,
            resource=resource,
            impact_bin_edges=impact_bin_edges,
        )


@applies_to_events([RiverineInundation])
class ThermalPowerGeneratingRiverineInundationModel(ThermalPowerGeneratingInundationModel):
    def __init__(
        self,
        *,
        indicator_id: str = "flood_depth",
        resource: str = ThermalPowerGeneratingInundationModel._default_resource,
        impact_bin_edges=ThermalPowerGeneratingInundationModel._default_impact_bin_edges
    ):
        # by default request HazardModel to use "MIROC-ESM-CHEM" GCM
        super().__init__(
            event_type=RiverineInundation,
            indicator_id=indicator_id,
            resource=resource,
            impact_bin_edges=impact_bin_edges,
        )
